-- Migration 010: Booking Transaction Function
-- Purpose: Create atomic transaction for booking creation
-- Author: Cascade AI + Tomita
-- Date: 2025-11-13
-- Related: Ver-3.4 FIX 1 - Add Transactions

-- Description:
-- Creates an RPC function that wraps booking creation (bookings, segments, pricing, services)
-- in a single PostgreSQL transaction. This ensures ALL OR NOTHING behavior for data integrity.
-- If any step fails, all changes are automatically rolled back.

-- Drop function if exists (for re-running migration)
DROP FUNCTION IF EXISTS create_booking_transaction(JSONB, JSONB[], JSONB, JSONB[]);

-- Create RPC function for atomic booking creation
CREATE OR REPLACE FUNCTION create_booking_transaction(
  p_booking JSONB,
  p_segments JSONB[],
  p_pricing JSONB,
  p_services JSONB[] DEFAULT ARRAY[]::JSONB[]
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_booking_id UUID;
  v_reference TEXT;
  v_segment JSONB;
  v_service JSONB;
BEGIN
  -- 1. INSERT booking (reference will be auto-generated by trigger)
  -- The booking_reference_trigger handles reference generation using booking_reference_seq
  INSERT INTO bookings (
    customer_id,
    operator_id,
    category,
    trip_type,
    start_at,
    passenger_count,
    bag_count,
    child_seats,
    extra_stops,
    distance_miles,
    duration_min,
    flight_number,
    notes,
    currency,
    payment_method,
    payment_status,
    booking_status,
    status,
    return_date,
    return_time,
    return_flight_number,
    hours,
    billing_entity_id,
    corporate_account_id,
    organization_id,
    booking_source
  ) VALUES (
    (p_booking->>'customer_id')::UUID,
    p_booking->>'operator_id',
    p_booking->>'category',
    COALESCE(p_booking->>'trip_type', 'oneway'),
    (p_booking->>'start_at')::TIMESTAMP,
    COALESCE((p_booking->>'passenger_count')::INT, 1),
    COALESCE((p_booking->>'bag_count')::INT, 0),
    COALESCE((p_booking->>'child_seats')::INT, 0),
    COALESCE((p_booking->>'extra_stops')::INT, 0),
    (p_booking->>'distance_miles')::NUMERIC,
    (p_booking->>'duration_min')::INT,
    p_booking->>'flight_number',
    p_booking->>'notes',
    COALESCE(p_booking->>'currency', 'GBP'),
    COALESCE(p_booking->>'payment_method', 'CARD'),
    COALESCE(p_booking->>'payment_status', 'pending'),
    COALESCE(p_booking->>'booking_status', 'draft'),
    COALESCE(p_booking->>'status', 'NEW'),
    (p_booking->>'return_date')::DATE,
    (p_booking->>'return_time')::TIME,
    p_booking->>'return_flight_number',
    COALESCE((p_booking->>'hours')::INT, 1),
    (p_booking->>'billing_entity_id')::UUID,
    (p_booking->>'corporate_account_id')::UUID,
    (p_booking->>'organization_id')::UUID,
    COALESCE(p_booking->>'booking_source', 'web')
  )
  RETURNING id, reference INTO v_booking_id, v_reference;
  
  -- 2. INSERT segments (pickup, destination, stops)
  IF array_length(p_segments, 1) > 0 THEN
    FOREACH v_segment IN ARRAY p_segments LOOP
      INSERT INTO booking_segments (
        booking_id,
        seq_no,
        role,
        place_text,
        place_label,
        lat,
        lng
      ) VALUES (
        v_booking_id,
        (v_segment->>'seq_no')::INT,
        v_segment->>'role',
        v_segment->>'place_text',
        v_segment->>'place_label',
        (v_segment->>'lat')::NUMERIC,
        (v_segment->>'lng')::NUMERIC
      );
    END LOOP;
  END IF;
  
  -- 3. INSERT pricing (1:1 with booking)
  INSERT INTO booking_pricing (
    booking_id,
    price,
    currency,
    extras_total,
    platform_fee,
    platform_commission_pct,
    operator_net,
    driver_payout,
    driver_commission_pct,
    payment_method,
    payment_status
  ) VALUES (
    v_booking_id,
    (p_pricing->>'price')::NUMERIC,
    COALESCE(p_pricing->>'currency', 'GBP'),
    (p_pricing->>'extras_total')::NUMERIC,
    (p_pricing->>'platform_fee')::NUMERIC,
    (p_pricing->>'platform_commission_pct')::NUMERIC,
    (p_pricing->>'operator_net')::NUMERIC,
    (p_pricing->>'driver_payout')::NUMERIC,
    (p_pricing->>'driver_commission_pct')::NUMERIC,
    COALESCE(p_pricing->>'payment_method', 'CARD'),
    COALESCE(p_pricing->>'payment_status', 'pending')
  );
  
  -- 4. INSERT services (optional extras)
  IF array_length(p_services, 1) > 0 THEN
    FOREACH v_service IN ARRAY p_services LOOP
      INSERT INTO booking_services (
        booking_id,
        service_code,
        quantity,
        unit_price,
        notes
      ) VALUES (
        v_booking_id,
        v_service->>'service_code',
        COALESCE((v_service->>'quantity')::INT, 1),
        (v_service->>'unit_price')::NUMERIC,
        v_service->>'notes'
      );
    END LOOP;
  END IF;
  
  -- 5. Return success with booking details
  RETURN jsonb_build_object(
    'success', TRUE,
    'booking_id', v_booking_id,
    'reference', v_reference,
    'message', 'Booking created successfully'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    -- Automatic ROLLBACK of ALL operations
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', SQLERRM,
      'error_code', SQLSTATE,
      'message', 'Transaction rolled back due to error'
    );
END;
$$;

-- Grant execute permission to authenticated users and service role
GRANT EXECUTE ON FUNCTION create_booking_transaction(JSONB, JSONB[], JSONB, JSONB[]) TO authenticated;
GRANT EXECUTE ON FUNCTION create_booking_transaction(JSONB, JSONB[], JSONB, JSONB[]) TO service_role;

-- Add comment for documentation
COMMENT ON FUNCTION create_booking_transaction IS 
'Creates a complete booking with segments, pricing, and services in a single atomic transaction.
Reference is auto-generated by booking_reference_trigger using booking_reference_seq.
All operations are rolled back automatically if any step fails.

Parameters:
- p_booking: JSONB object with booking data (customer_id, operator_id, category, etc.)
- p_segments: JSONB array of segments (pickup, destination, stops)
- p_pricing: JSONB object with pricing data (price, currency, fees, etc.)
- p_services: JSONB array of services (optional extras like meet_greet, child_seat, etc.)

Returns:
- JSONB object with success status, booking_id, and reference on success
- JSONB object with error details on failure

Example:
SELECT create_booking_transaction(
  ''{"customer_id": "uuid-here", "operator_id": "premium-exec", "category": "EXEC", ...}''::jsonb,
  ARRAY[''{"seq_no": 1, "role": "pickup", "place_text": "Heathrow T5"}''::jsonb],
  ''{"price": 95.00, "currency": "GBP", ...}''::jsonb,
  ARRAY[''{"service_code": "meet_greet", "quantity": 1, "unit_price": 20}''::jsonb]
);';
