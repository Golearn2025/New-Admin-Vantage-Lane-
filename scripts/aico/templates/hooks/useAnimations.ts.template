'use client';

import { useState, useCallback, useEffect, useRef } from 'react';
import type { {{COMPONENT_NAME}}Manager } from '../{{COMPONENT_NAME}}.types';

/**
 * ✨ use{{COMPONENT_NAME}}Animations - Generated by AI Scaffolder
 * Animation & Micro-interactions Hook pentru {{COMPONENT_NAME}}
 * 
 * Responsabilități:
 * - Framer Motion integration
 * - CSS transitions management
 * - Micro-interactions & feedback
 * - Performance-optimized animations
 */
export function use{{COMPONENT_NAME}}Animations(manager: {{COMPONENT_NAME}}Manager) {
  const [isHovered, setIsHovered] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [isPressed, setIsPressed] = useState(false);
  const animationFrameRef = useRef<number>();

  // Hover animations
  const startHover = useCallback(() => {
    setIsHovered(true);
  }, []);

  const endHover = useCallback(() => {
    setIsHovered(false);
  }, []);

  // Focus animations
  const startFocus = useCallback(() => {
    setIsFocused(true);
  }, []);

  const endFocus = useCallback(() => {
    setIsFocused(false);
  }, []);

  // Press animations
  const startPress = useCallback(() => {
    setIsPressed(true);
  }, []);

  const endPress = useCallback(() => {
    setIsPressed(false);
  }, []);

  // Loading pulse animation
  const pulseAnimation = useCallback(() => {
    if (!manager.isLoading) return;
    
    const animate = () => {
      // Custom pulse logic here
      {{PULSE_ANIMATION_LOGIC}}
      
      if (manager.isLoading) {
        animationFrameRef.current = requestAnimationFrame(animate);
      }
    };
    
    animationFrameRef.current = requestAnimationFrame(animate);
  }, [manager.isLoading]);

  // Entrance animation
  const entranceAnimation = useCallback(() => {
    {{ENTRANCE_ANIMATION_LOGIC}}
  }, []);

  // Exit animation
  const exitAnimation = useCallback(() => {
    {{EXIT_ANIMATION_LOGIC}}
  }, []);

  // Error shake animation
  const errorShake = useCallback(() => {
    if (!manager.error) return;
    
    {{ERROR_SHAKE_LOGIC}}
  }, [manager.error]);

  // Cleanup animation frame on unmount
  useEffect(() => {
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, []);

  // Trigger animations based on state changes
  useEffect(() => {
    if (manager.isLoading) {
      pulseAnimation();
    }
  }, [manager.isLoading, pulseAnimation]);

  useEffect(() => {
    if (manager.error) {
      errorShake();
    }
  }, [manager.error, errorShake]);

  {{CUSTOM_ANIMATION_HOOKS}}

  // Animation variants for Framer Motion
  const variants = {
    initial: {
      opacity: 0,
      scale: 0.95,
      {{INITIAL_VARIANT}}
    },
    animate: {
      opacity: 1,
      scale: 1,
      {{ANIMATE_VARIANT}}
    },
    hover: {
      scale: isHovered ? 1.02 : 1,
      {{HOVER_VARIANT}}
    },
    focus: {
      boxShadow: isFocused ? '0 0 0 2px hsl(var(--primary))' : '0 0 0 0px transparent',
      {{FOCUS_VARIANT}}
    },
    press: {
      scale: isPressed ? 0.98 : 1,
      {{PRESS_VARIANT}}
    },
    loading: {
      opacity: manager.isLoading ? 0.7 : 1,
      {{LOADING_VARIANT}}
    },
    error: {
      borderColor: manager.error ? 'hsl(var(--destructive))' : 'hsl(var(--border))',
      {{ERROR_VARIANT}}
    }
  };

  return {
    // State
    isHovered,
    isFocused,
    isPressed,
    
    // Actions
    startHover,
    endHover,
    startFocus,
    endFocus,
    startPress,
    endPress,
    
    // Animations
    entranceAnimation,
    exitAnimation,
    
    // Framer Motion
    variants,
    
    {{CUSTOM_ANIMATIONS_RETURNS}}
  };
}
